# 数据加载模块# 功能：# - 加载qa_pairs_rag.json文件# - 数据清洗和预处理# - 提取问题、答案、关键词等字段import jsonimport loggingfrom pathlib import Pathfrom typing import List, Dict, Anyimport oslogger = logging.getLogger(__name__)class QADataLoader:    """问答对数据加载器"""    def __init__(self, data_path: str = None):        """        初始化数据加载器        Args:            data_path: JSON数据文件路径        """        if data_path is None:            # 使用默认路径（相对于项目根目录）            # src/data_loader.py -> src -> project_root            project_root = Path(__file__).resolve().parent.parent            self.data_path = project_root / "data" / "raw" / "qa_pairs_rag.json"        else:            self.data_path = Path(data_path)        self.qa_pairs = []    def load_data(self) -> List[Dict[str, Any]]:        """        加载JSON数据文件        Returns:            问答对列表        """        try:            if not self.data_path.exists():                raise FileNotFoundError(f"数据文件不存在: {self.data_path}")            with open(self.data_path, 'r', encoding='utf-8') as f:                data = json.load(f)            # 支持多种JSON格式            if isinstance(data, list):                self.qa_pairs = data            elif isinstance(data, dict) and 'qa_pairs' in data:                self.qa_pairs = data['qa_pairs']            else:                raise ValueError("不支持的JSON格式")            logger.info(f"成功加载 {len(self.qa_pairs)} 条问答对")            return self.qa_pairs        except Exception as e:            logger.error(f"加载数据失败: {e}")            raise    def clean_text(self, text: str) -> str:        """        清洗文本数据        Args:            text: 原始文本        Returns:            清洗后的文本        """        if not text:            return ""        # 去除首尾空白        text = text.strip()        # 去除多余空格        text = ' '.join(text.split())        # 去除特殊控制字符        text = ''.join(char for char in text if ord(char) >= 32 or char == '\n')        return text    def preprocess_data(self) -> List[Dict[str, Any]]:        """        预处理数据，补充所有字段        Returns:            预处理后的问答对列表        """        processed_data = []        for idx, qa in enumerate(self.qa_pairs):            try:                # 提取和清洗字段                processed_qa = {                    'id': qa.get('id', idx),                    'question': self.clean_text(qa.get('question', '')),                    'answer': self.clean_text(qa.get('answer', '')),                    'keywords': qa.get('keywords', []),                    'category': qa.get('category', 'general'),                    'created_at': qa.get('created_at', None),                    'question_length': qa.get('question_length', len(qa.get('question', ''))),                    'answer_length': qa.get('answer_length', len(qa.get('answer', ''))),                    'metadata': qa.get('metadata', {})                }                # 验证必填字段                if not processed_qa['question'] or not processed_qa['answer']:                    logger.warning(f"跳过无效数据: ID {processed_qa['id']}")                    continue                # 合并问题和答案用于向量化                processed_qa['combined_text'] = f"{processed_qa['question']} {processed_qa['answer']}"                processed_data.append(processed_qa)            except Exception as e:                logger.error(f"处理第 {idx} 条数据时出错: {e}")                continue        logger.info(f"预处理完成，有效数据: {len(processed_data)} 条")        return processed_data    def get_statistics(self) -> Dict[str, Any]:        """        获取数据统计信息        Returns:            统计信息字典        """        if not self.qa_pairs:            return {}        categories = {}        total_questions = len(self.qa_pairs)        for qa in self.qa_pairs:            category = qa.get('category', 'unknown')            categories[category] = categories.get(category, 0) + 1        stats = {            'total_count': total_questions,            'categories': categories,            'avg_question_length': sum(len(qa.get('question', '')) for qa in self.qa_pairs) / total_questions,            'avg_answer_length': sum(len(qa.get('answer', '')) for qa in self.qa_pairs) / total_questions        }        return stats