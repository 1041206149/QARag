# 向量检索模块# 功能：# - 使用FAISS构建向量索引# - 实现语义相似度搜索# - 返回Top-K相关文档import loggingimport picklefrom pathlib import Pathfrom typing import List, Dict, Any, Tupleimport numpy as nplogger = logging.getLogger(__name__)class VectorRetriever:    """基于FAISS的向量检索器"""    def __init__(self, embedding_model=None):        """        初始化检索器        Args:            embedding_model: EmbeddingModel实例（用于查询向量化）        """        self.embedding_model = embedding_model        self.index = None        self.qa_pairs = []        self.embedding_dim = None        # 使用项目根目录的路径        # src/retriever.py -> src -> project_root        project_root = Path(__file__).resolve().parent.parent        self.index_path = project_root / "vector_store" / "faiss_index"        self.index_path.mkdir(parents=True, exist_ok=True)    def build_index(self, embeddings: np.ndarray, qa_pairs: List[Dict[str, Any]]):        """        构建FAISS索引        Args:            embeddings: 向量矩阵 (n_samples, dim)            qa_pairs: 问答对列表        """        try:            import faiss            self.qa_pairs = qa_pairs            self.embedding_dim = embeddings.shape[1]            logger.info(f"正在构建FAISS索引，向量数量: {len(embeddings)}, 维度: {self.embedding_dim}")            # 创建FAISS索引（使用L2距离）            self.index = faiss.IndexFlatL2(self.embedding_dim)            # 归一化向量（用于余弦相似度）            embeddings_normalized = embeddings / np.linalg.norm(embeddings, axis=1, keepdims=True)            # 添加向量到索引            self.index.add(embeddings_normalized.astype('float32'))            logger.info(f"FAISS索引构建完成，包含 {self.index.ntotal} 个向量")        except ImportError:            logger.error("请先安装 faiss: pip install faiss-cpu")            raise        except Exception as e:            logger.error(f"构建索引失败: {e}")            raise    def search(self, query: str, top_k: int = 3) -> List[Dict[str, Any]]:        """        语义搜索        Args:            query: 查询文本            top_k: 返回前K个结果        Returns:            相关文档列表，包含相似度分数        """        if self.index is None:            raise ValueError("索引未构建，请先调用 build_index()")        if self.embedding_model is None:            raise ValueError("需要 embedding_model 来向量化查询")        try:            # 1. 向量化查询            query_embedding = self.embedding_model.encode_texts([query], show_progress=False)            query_embedding = query_embedding / np.linalg.norm(query_embedding)            # 2. 搜索最相似的向量            distances, indices = self.index.search(query_embedding.astype('float32'), top_k)            # 3. 构建结果            results = []            for i, (idx, distance) in enumerate(zip(indices[0], distances[0])):                if idx < len(self.qa_pairs):                    result = {                        'rank': i + 1,                        'qa_pair': self.qa_pairs[idx],                        'distance': float(distance),                        'similarity': float(1 - distance / 2)  # 转换为余弦相似度                    }                    results.append(result)            logger.info(f"检索到 {len(results)} 个相关文档")            return results        except Exception as e:            logger.error(f"检索失败: {e}")            raise    def save_index(self, filename: str = "faiss.index"):        """        保存FAISS索引        Args:            filename: 索引文件名        """        if self.index is None:            raise ValueError("索引未构建")        try:            import faiss            # 保存FAISS索引            index_file = self.index_path / filename            faiss.write_index(self.index, str(index_file))            # 保存元数据            metadata = {                'qa_pairs': self.qa_pairs,                'embedding_dim': self.embedding_dim            }            metadata_file = self.index_path / f"{filename}.metadata.pkl"            with open(metadata_file, 'wb') as f:                pickle.dump(metadata, f)            logger.info(f"索引已保存到: {index_file}")        except Exception as e:            logger.error(f"保存索引失败: {e}")            raise    def load_index(self, filename: str = "faiss.index"):        """        加载FAISS索引        Args:            filename: 索引文件名        """        try:            import faiss            # 加载FAISS索引            index_file = self.index_path / filename            if not index_file.exists():                raise FileNotFoundError(f"索引文件不存在: {index_file}")            self.index = faiss.read_index(str(index_file))            # 加载元数据            metadata_file = self.index_path / f"{filename}.metadata.pkl"            with open(metadata_file, 'rb') as f:                metadata = pickle.load(f)            self.qa_pairs = metadata['qa_pairs']            self.embedding_dim = metadata['embedding_dim']            logger.info(f"索引已加载，包含 {self.index.ntotal} 个向量")        except Exception as e:            logger.error(f"加载索引失败: {e}")            raise